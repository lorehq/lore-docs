{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Lore","text":"<p>Your coding agent forgets everything between sessions. Lore fixes that.</p> <p>Lore is a lightweight framework that gives coding agents persistent memory. Install it, work normally, and your agent starts building knowledge that compounds across sessions.</p>"},{"location":"#what-you-get","title":"What You Get","text":"<ul> <li>Knowledge Capture \u2014 Run <code>/lore-capture</code> and the agent documents gotchas as reusable skills and maps your context through docs. API quirks, auth tricks, encoding issues \u2014 all persist across sessions.</li> <li>Semantic Search &amp; Docs UI \u2014 Semantic search over your full knowledge base and a live docs UI \u2014 both running locally. Run <code>/lore-docker</code> to start the sidecar. Agents query by meaning, not just filename, and get ranked results. Highly recommended. Without Docker, agents fall back to Grep/Glob.</li> <li>Delegation \u2014 An orchestrator/worker pattern where the main model dispatches execution to cheaper models that run in parallel. Less token spend, cleaner context windows.</li> <li>Work Continuity \u2014 Roadmaps and plans persist across sessions and surface at startup, so long-running projects have persistent context from day one.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install with <code>npx create-lore my-project</code> and check the Getting Started guide.</p> <p>No configuration required. The framework activates through hooks when you start your agent. Customize <code>docs/context/agent-rules.md</code> to teach the agent about your project.</p>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li>Getting Started \u2014 install and first session walkthrough</li> <li>How It Works \u2014 architecture, knowledge capture, session acceleration</li> <li>Working with Lore \u2014 tips, commands, and effective use</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Lore are documented here. See Production Readiness for versioning policy. For full commit history, see GitHub Releases.</p>"},{"location":"changelog/#v0110-2026-02-22","title":"v0.11.0 \u2014 2026-02-22","text":"<p>Worker agent tier naming simplification.</p> <p>Worker agents:</p> <ul> <li><code>lore-worker-agent</code> renamed to <code>lore-worker</code></li> <li><code>lore-worker-default</code> variant removed \u2014 <code>lore-worker</code> is now the single standard worker</li> <li><code>lore-worker-fast</code> and <code>lore-worker-powerful</code> are only generated when the corresponding tier key is present in <code>subagentDefaults.claude</code></li> </ul> <p>Configuration:</p> <ul> <li>Flat <code>subagentDefaults</code> schema removed \u2014 no backward compatibility provided</li> <li>New nested schema: <code>subagentDefaults.claude = { fast?, default?, powerful? }</code></li> <li><code>lore-worker</code> uses <code>claude.default</code> model if set, otherwise omits the model field (platform picks its own default)</li> </ul>"},{"location":"changelog/#v0100-2026-02-21","title":"v0.10.0 \u2014 2026-02-21","text":"<p>Hook profiles, operator.gitignore persistence, and framework consolidation.</p> <p>Configuration:</p> <ul> <li>Hook profiles (<code>minimal</code>, <code>standard</code>, <code>discovery</code>) \u2014 configurable via <code>profile</code> in <code>.lore/config.json</code></li> <li>Bash tracking now threshold-only: silent below nudge threshold, emits only at crossing points</li> <li><code>discovery</code> profile: nudge=5, warn=10 (aggressive capture for exploration-heavy work)</li> <li><code>standard</code> profile: nudge=15, warn=30 (default)</li> </ul> <p>Operator gitignore persistence:</p> <ul> <li><code>sync-framework.sh</code> now merges <code>.lore/operator.gitignore</code> into <code>.gitignore</code> on every update</li> <li>Operator-added ignore rules survive framework updates \u2014 no more re-adding after <code>/lore-update</code></li> <li>Bootstraps an empty <code>.lore/operator.gitignore</code> template on first sync</li> </ul> <p>New skills:</p> <ul> <li><code>/lore-docker</code> \u2014 start, stop, and inspect the local docs UI (Docker + mkdocs fallback)</li> <li><code>/lore-delegate</code> \u2014 delegation recipe: how to construct worker prompts with context, scope, return contract</li> </ul> <p>Framework layout:</p> <ul> <li>All framework dirs consolidated under <code>.lore/</code> (hooks, lib, scripts, skills, agents)</li> <li><code>ensure-structure.sh</code> \u2014 idempotent structure init for new instances</li> <li><code>docker-compose.yml</code> moved into <code>.lore/</code> and synced as framework-owned</li> </ul>"},{"location":"changelog/#v090-2026-02-20","title":"v0.9.0 \u2014 2026-02-20","text":"<p>Health sweep, code hardening, and messaging sync.</p> <p>Docs:</p> <ul> <li>Full health sweep across all 19 doc pages (reduce, verify, polish)</li> <li>Merged <code>commands.md</code> into <code>interaction.md</code></li> <li>Verified 373 doc claims against source code \u2014 fixed 11 wrong/outdated items</li> <li>Standardized terminology (\"Lore instance\" not \"Lore project\"), command style (<code>/lore-link</code> not <code>lore link</code>)</li> </ul> <p>Code:</p> <ul> <li><code>analyze-hook-logs.sh</code>: consolidated 6 Node processes into one, fixed shell injection risk by passing log path via <code>process.argv</code></li> <li><code>generate-nav.sh</code>: warns to stderr when auto-creating missing <code>index.md</code> instead of silently scaffolding</li> <li><code>create-lore</code>: added path traversal guard \u2014 rejects target directories outside cwd</li> <li>Prettier formatting fixes across 6 files</li> </ul> <p>Messaging:</p> <ul> <li>Synced all READMEs and launch content to current worker delegation model</li> <li>Removed stale <code>domain</code> field references and old \"skills get agents\" language</li> <li>Updated technical claims with current banner format and function references</li> </ul>"},{"location":"changelog/#v081-2026-02-19","title":"v0.8.1 \u2014 2026-02-19","text":"<p>CI stabilization and release automation.</p> <ul> <li>Fixed shellcheck errors, prettier drift, version mismatch (0.7.0 \u2192 0.8.1)</li> <li>Added macOS shellcheck install to CI</li> <li>Resolved macOS test flakiness (<code>/var/folders/</code> \u2192 <code>/private/var/folders/</code> symlink)</li> <li>All 4 CI matrix jobs green (Ubuntu + macOS, Node 18 + 20)</li> <li>Tag-driven release automation via GitHub Actions</li> <li><code>bump-version.sh</code> \u2014 single command to update all version references across repos</li> <li>Expanded <code>check-version-sync.sh</code> to catch package-lock.json and SECURITY.md drift</li> </ul>"},{"location":"changelog/#v060-2026-02-18","title":"v0.6.0 \u2014 2026-02-18","text":"<p>Knowledge architecture restructure and platform parity.</p> <p>Knowledge architecture:</p> <ul> <li>Split <code>docs/context/</code> into <code>context/</code> (rules, conventions) + <code>knowledge/</code> (reference material)</li> <li>Broader environment subdirs: <code>inventory/</code>, <code>decisions/</code>, <code>reference/</code>, <code>diagrams/</code></li> <li>Nav reorder: Work \u2192 Knowledge \u2192 Context \u2192 Guides</li> </ul> <p>Platform parity:</p> <ul> <li>OpenCode context-path-guide plugin (matches Claude Code's PreToolUse hook)</li> <li>Cursor condensed banner on every prompt (compaction resilience)</li> <li>Cursor knowledge capture reminders via <code>beforeSubmitPrompt</code></li> <li>Cursor <code>.plans/</code> routing rule</li> </ul> <p>Quality:</p> <ul> <li>Safe <code>.gitignore</code> unlink with BEGIN/END markers in <code>lore-link.sh</code></li> <li>Debug logging (<code>LORE_DEBUG=1</code>) replaces silent <code>catch {}</code> blocks</li> <li>Version sync CI check, nav staleness CI guard</li> <li>Pinned Docker deps for reproducible docs builds</li> <li>107 tests passing (up from 69)</li> </ul>"},{"location":"changelog/#v050-2026-02-17","title":"v0.5.0 \u2014 2026-02-17","text":"<p>Standardization and knowledge architecture groundwork.</p> <ul> <li><code>lore-</code> prefix on all user-invocable skills</li> <li>Configurable <code>treeDepth</code> via <code>.lore-config</code></li> <li>Archives visible in nav, archive cleanup in <code>/lore-consolidate</code></li> <li>156 tests passing</li> </ul>"},{"location":"changelog/#v040-2026-02-16","title":"v0.4.0 \u2014 2026-02-16","text":"<p>Cursor support and cross-repo linking.</p> <ul> <li>Cursor hooks: <code>sessionStart</code>, <code>beforeSubmitPrompt</code>, <code>beforeReadFile</code>, <code>afterFileEdit</code>, <code>afterShellExecution</code></li> <li>Vendor-agnostic instructions: <code>.lore/instructions.md</code> as canonical source</li> <li>Platform-neutral skills and agents: <code>.lore/</code> canonical, platform copies generated</li> <li><code>lore-link</code> \u2014 hub-spoke cross-repo hook generation for all three platforms</li> </ul>"},{"location":"changelog/#v030-2026-02-15","title":"v0.3.0 \u2014 2026-02-15","text":"<p>OpenCode support via shared lib architecture.</p> <ul> <li>Shared core logic: <code>lib/banner.js</code>, <code>lib/tracker.js</code>, <code>lib/memory-guard.js</code></li> <li>OpenCode plugins: three ESM adapters in <code>.opencode/plugins/</code></li> <li>Claude Code hooks refactored to thin CJS adapters</li> <li>Configurable escalation thresholds via <code>.lore-config</code></li> <li>69 tests passing</li> </ul>"},{"location":"changelog/#v020-2026-02-14","title":"v0.2.0 \u2014 2026-02-14","text":"<p>Framework hardening.</p> <ul> <li>Dynamic nav generation with auto-scaffolding</li> <li>Agent rules extraction (<code>docs/context/agent-rules.md</code>)</li> <li>Community health files (CONTRIBUTING.md, CODE_OF_CONDUCT.md, SECURITY.md)</li> <li>Knowledge map in session banner</li> <li>Tests for hooks and scripts (24 tests)</li> <li>Versioning and upgrade path (<code>.lore-config</code>, <code>sync-framework.sh</code>, <code>/lore-update</code>)</li> </ul>"},{"location":"changelog/#v010-2026-02-14","title":"v0.1.0 \u2014 2026-02-14","text":"<p>Initial release. GitHub org, domains, licensing, security baseline.</p>"},{"location":"cost-evidence/","title":"Cost Evidence","text":"<p>This page presents cost data from a controlled comparison between raw Claude Code and Lore on the same task. It is directional evidence from a single test, not a statistically validated benchmark. The numbers are real but the sample size is small \u2014 treat them as an honest first data point, not a guarantee.</p> <p>If you're skeptical, good. Read the limitations first, then decide if the methodology is credible enough to run your own comparison.</p>"},{"location":"cost-evidence/#methodology","title":"Methodology","text":"<p>Task: Determine whether current inventory can fill all orders from last week. Two mock APIs (orders and inventory) with deliberate gotchas \u2014 version traps, required headers, non-obvious query parameters.</p> <p>Four conditions, same task, same day:</p> Condition Framework Orchestrator Workers Prior Knowledge Raw Cold None Opus 4.6 \u2014 (inline) None Raw Warm None Opus 4.6 \u2014 (inline) Claude Code auto-memory from cold run Lore Cold Lore v0.10.1 Opus 4.6 Haiku 4.5 None Lore Warm Lore v0.10.1 Opus 4.6 Haiku 4.5 Skills + env docs captured from cold run <p>\"Cold\" means no prior knowledge of the APIs. \"Warm\" means a previous session interacted with the same APIs.</p> <p>Pricing basis: API-equivalent rates with a blended 75/25 input/output ratio. These tests ran on Claude Max (flat-rate subscription), so cost figures represent what the compute would cost at API rates.</p> Model Input Output Blended (75/25) Opus 4.6 $5.00/MTok $25.00/MTok $10.00/MTok Haiku 4.5 $1.00/MTok $5.00/MTok $2.00/MTok <p>Source: Anthropic API Pricing</p>"},{"location":"cost-evidence/#results","title":"Results","text":""},{"location":"cost-evidence/#per-run-cost","title":"Per-Run Cost","text":"Raw Cold Raw Warm Lore Cold Lore Warm Opus tokens ~60k ~50k ~15k ~15k Haiku tokens \u2014 \u2014 37.5k 31.5k Opus cost $0.600 $0.500 $0.150 $0.150 Haiku cost \u2014 \u2014 $0.075 $0.063 Answer cost $0.600 $0.500 $0.225 $0.213 vs Raw Cold \u2014 -17% -63% -65% Time 1m 17s 56s 1m 21s 1m 15s <p>Lore Cold includes a one-time capture cost of $0.120 (~12k Opus tokens), bringing total session cost to $0.345 \u2014 still 42% cheaper than Raw Cold.</p>"},{"location":"cost-evidence/#key-observations","title":"Key Observations","text":"<p>Delegation alone is cheaper. Even on a cold run with zero prior knowledge, the answer cost ($0.225) is 63% cheaper than raw Claude ($0.600). No knowledge base needed. The savings come entirely from routing API exploration to Haiku workers instead of running it inline on Opus.</p> <p>Built-in memory doesn't help. Raw Warm ($0.500) shows no meaningful improvement over Raw Cold ($0.600). Claude Code's auto-memory stores preferences, not operational knowledge \u2014 API endpoints, required headers, and gotchas are lost between sessions.</p> <p>Knowledge reuse is a secondary lever. Lore Warm ($0.213) vs Lore Cold ($0.225) saves another 5% by reducing exploration. The primary savings come from delegation and model tiering, not from accumulated knowledge.</p>"},{"location":"cost-evidence/#capture-roi","title":"Capture ROI","text":"Metric Value Capture investment $0.120 (one-time) Savings vs Raw Cold per warm run $0.387 Savings vs Raw Warm per warm run $0.287 Break-even First warm run Net ROI after 1 warm run +$0.167 to +$0.267 (139\u2013223%) Net ROI after 5 warm runs +$1.315 to +$1.815 <p>The $0.120 capture investment pays for itself on the first reuse. Every subsequent run saves $0.29\u2013$0.39 at near-zero marginal cost.</p>"},{"location":"cost-evidence/#where-the-savings-come-from","title":"Where the Savings Come From","text":"Mechanism What It Does Impact Model tiering Worker compute on Haiku ($2/MTok) instead of Opus ($10/MTok) 5x cheaper per worker token Context isolation Workers run in fresh contexts; raw Claude accumulates all tool results in one growing context Lower per-call input cost Knowledge reuse Warm workers skip exploration (14 tool uses vs 47 cold) 70% fewer round-trips Ambiguity scan Flags vague inputs before delegating to cheap models Prevents reasoning errors in workers <p>Model tiering and context isolation are structural \u2014 they apply from the first run. Knowledge reuse and ambiguity scanning compound over time as the knowledge base grows.</p> <p>For how these mechanisms work, see How It Works: Delegation and Configuration.</p>"},{"location":"cost-evidence/#limitations","title":"Limitations","text":"<p>This is not a benchmark</p> <p>The following limitations mean these results should inform your expectations, not set them.</p> <ul> <li>N=1. Single run per condition. LLM behavior is probabilistic \u2014 the same task produced 15\u201330 tool uses across different cold runs. Statistical confidence requires 5\u201310 runs per condition.</li> <li>One task type. API exploration with mock services. Results may differ for code generation, refactoring, debugging, or other task patterns.</li> <li>Orchestrator tokens estimated. Only worker token counts were captured from the Claude Code UI. Orchestrator tokens inferred from typical context patterns.</li> <li>Subscription pricing. Tests ran on Claude Max (flat-rate), not metered API. Cost figures are API-equivalent estimates, relevant for API users and for understanding relative efficiency.</li> <li>No cross-tool validation. Knowledge captured on Claude Code should benefit Cursor and OpenCode sessions \u2014 not yet tested.</li> </ul>"},{"location":"cost-evidence/#reproduce-it","title":"Reproduce It","text":"<p>Run the same comparison on your own tasks:</p> <ol> <li>Pick a task that involves API exploration or multi-step tool use</li> <li>Run it on raw Claude Code (no framework) and note the token count from the UI</li> <li>Install Lore (<code>npx create-lore</code>), run the same task, and compare</li> <li>Run a second Lore session after knowledge capture to measure the warm delta</li> </ol> <p>Lore logs hook events and worker spawns to the session. Use these to reconstruct token counts per worker and compare against the raw baseline.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 18+ \u2014 for the installer</li> <li>A supported coding agent \u2014 Claude Code, Cursor, or OpenCode</li> <li>Docker (Docker Desktop or Engine) \u2014 highly recommended for semantic search and docs UI; not required</li> </ul>"},{"location":"getting-started/#install","title":"Install","text":"<pre><code>npx create-lore my-project\ncd my-project\n</code></pre>"},{"location":"getting-started/#what-you-get","title":"What You Get","text":"<p>The installer creates a <code>.lore/</code> directory with skills, agents, and instructions; per-platform directories (<code>.claude/</code>, <code>.cursor/</code>, <code>.opencode/</code>) with hooks and configs; and a <code>docs/</code> tree for context, knowledge, and work tracking. See Platform Support for a full breakdown of hook directories.</p>"},{"location":"getting-started/#customize-your-project-context","title":"Customize Your Project Context","text":"<p>Open <code>docs/context/agent-rules.md</code> and describe your project. This file is injected into every agent session as project context:</p> <ul> <li>About \u2014 what the project does, what domain it's in</li> <li>Agent Behavior \u2014 communication style, preferences, constraints</li> </ul> <p>Coding and docs conventions go in <code>docs/context/conventions/</code> \u2014 also injected every session as a separate section.</p> <p>The agent sees both before your first prompt every session.</p> <p>For personal preferences that shouldn't be shared via git, edit <code>docs/knowledge/local/operator-profile.md</code>. This file is gitignored and injected into every session alongside project context. The default template is ignored until you customize it.</p>"},{"location":"getting-started/#start-the-docker-sidecar","title":"Start the Docker Sidecar","text":"<p>The Docker sidecar gives agents semantic search over your full knowledge base and opens a live MkDocs site at <code>localhost:PORT</code> for browsing it visually. Highly recommended \u2014 start it before your first session.</p> <pre><code>/lore-docker\n</code></pre> <p>Requires Docker (Docker Desktop or Docker Engine). First start pulls the image and loads models \u2014 about 1\u20132 minutes. Subsequent starts are fast.</p> <p>Without Docker, agents fall back to Grep/Glob search. That works for small knowledge bases; semantic search becomes noticeably better as your docs grow.</p> <p>See Docs UI &amp; Semantic Search for configuration and details.</p>"},{"location":"getting-started/#first-session","title":"First Session","text":"<p>Start your agent in the project directory:</p> <pre><code>claude       # Claude Code\ncursor .     # Cursor (open the project)\nopencode     # OpenCode\n</code></pre> <p>Work normally. Lore's hooks reinforce knowledge capture as you go. If you prefer opening a work repo in your IDE instead of the Lore instance directory, see lore link for an alternative that keeps hooks active.</p> <p>After substantive work, run <code>/lore-capture</code> to trigger a full knowledge capture pass.</p>"},{"location":"getting-started/#working-across-repos","title":"Working Across Repos","text":"<p>See Working Across Repos for the hub pattern and IDE linking.</p>"},{"location":"getting-started/#checking-status-and-updating","title":"Checking Status and Updating","text":"<p>Use <code>/lore-status</code> to verify your instance is healthy and <code>/lore-update</code> to pull the latest framework updates. See Commands for the full list, including <code>/lore-docker</code> for browsing your knowledge base.</p>"},{"location":"how-it-works/","title":"How It Works","text":"<p>AI agents are ephemeral \u2014 every session starts from zero. Lore wraps your coding agent in a persistent, git-versioned knowledge base so it picks up where it left off.</p>"},{"location":"how-it-works/#system-architecture","title":"System Architecture","text":"<pre><code>flowchart TB\n    User([User Request]) --&gt; Orchestrator\n\n    subgraph Orchestrator[\"Orchestrator\"]\n        direction TB\n        Parse[Parse Intent] --&gt; Decide{Delegate?}\n        Decide --&gt;|Yes| Select[Select skills from registry]\n    end\n\n    Decide --&gt;|No| Direct[Handle Directly]\n    Select --&gt; Spawn[Spawn Worker Agent]\n\n    subgraph Worker[\"Worker Agent\"]\n        direction TB\n        Load[Load skills + conventions] --&gt; Tools[Call Tools]\n        Tools --&gt; Result[Return Result]\n    end\n\n    Spawn --&gt; Worker\n    Direct --&gt; Tools2[Call Tools Directly]\n    Worker --&gt; Respond[Respond to User]\n    Tools2 --&gt; Respond\n\n    Respond --&gt; Capture\n\n    subgraph Capture[\"Knowledge Capture\"]\n        direction TB\n        H1[Capture Knowledge] --&gt; H2[Evaluate Skills]\n        H2 --&gt; H3[Check Consistency]\n    end\n\n    Capture --&gt; KB[(Knowledge Base)]\n    KB -.-&gt;|Next Session| Parse</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom  <p>When the Docker sidecar is running, agents query the knowledge base via semantic search rather than file Grep/Glob \u2014 returning ranked results by topic relevance.</p>"},{"location":"how-it-works/#three-goals","title":"Three Goals","text":""},{"location":"how-it-works/#1-knowledge-capture","title":"1. Knowledge Capture","text":"<p>Every session produces knowledge as a byproduct \u2014 endpoints, gotchas, org structure, tool parameters. Post-tool-use reminders encourage the agent to extract this into persistent documentation. When an operation produces non-obvious knowledge, it becomes a skill. The orchestrator finds relevant skills by name and description when delegating related tasks.</p>"},{"location":"how-it-works/#the-dont-ask-twice-loop","title":"The \"Don't Ask Twice\" Loop","text":"<pre><code>sequenceDiagram\n    participant S1 as Session N\n    participant Docs as docs/knowledge/\n    participant S2 as Session N+1\n\n    Note over S1: User asks about service org structure\n    S1-&gt;&gt;S1: Discovers org name is case-sensitive\n    S1-&gt;&gt;S1: Discovers available projects\n\n    Note over S1: Capture checkpoint\n    S1-&gt;&gt;Docs: Write integration docs + create skill with gotchas\n\n    Note over S2: Different session, same question\n    S2-&gt;&gt;Docs: Read docs \u2014 already knows org, projects, auth\n    Note over S2: Minimal rediscovery\n    S2-&gt;&gt;S2: Execute immediately with correct parameters</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"how-it-works/#what-gets-captured-where","title":"What Gets Captured Where","text":"Knowledge Type Destination Example API endpoints, URLs, services <code>docs/knowledge/environment/</code> Service API base URL Tool gotchas, auth quirks <code>.lore/skills/</code> Case-sensitive org name Dependencies, relationships <code>docs/knowledge/environment/</code> Which services connect to what Strategic initiatives <code>docs/work/roadmaps/</code> Cloud migration phases Tactical work <code>docs/work/plans/</code> Phase 1 networking setup Multi-step procedures <code>docs/knowledge/runbooks/</code> Deploy to staging"},{"location":"how-it-works/#ownership","title":"Ownership","text":"<p>See Platform Support: Sync Boundaries for the <code>lore-*</code> prefix convention and what sync overwrites.</p>"},{"location":"how-it-works/#how-skills-and-agents-emerge","title":"How Skills and Agents Emerge","text":"<pre><code>flowchart TD\n    op[Operation Completed] --&gt; gotcha{Hit any\\ngotchas?}\n    gotcha --&gt;|No| skip[No skill needed]\n    gotcha --&gt;|Yes| createSkill[Create skill]\n    createSkill --&gt; registry[Update registries]\n    registry --&gt; done[Skill available for\\nworker delegation]</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"how-it-works/#2-delegation","title":"2. Delegation","text":"<p>The orchestrator delegates work to worker agents \u2014 ephemeral context windows loaded with curated skills and conventions per-task. For compound requests, the orchestrator spawns multiple workers in parallel for independent branches and keeps dependency-gated steps sequential. For measured cost impact, see Cost Evidence.</p> <pre><code>flowchart TD\n    Request[Incoming Request] --&gt; Q1{Benefits from\\nfresh context?}\n    Q1 --&gt;|No| Direct[Handle Directly]\n    Q1 --&gt;|Yes| Skills[Select skills from registry]\n    Skills --&gt; Spawn[Spawn worker with\\nskills + conventions + scope]\n    Spawn --&gt; Execute[Worker executes task]\n    Execute --&gt; Review[Orchestrator reviews results]\n    Direct --&gt; Review\n    Review --&gt; Capture[Knowledge capture]</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom  Orchestrator Worker Agent Understand user intent Execute delegated task Select relevant skills Load what orchestrator specifies Coordinate multi-worker flows Stay within scope boundaries Handle knowledge capture Report gotchas and findings"},{"location":"how-it-works/#subagent-context-contract","title":"Subagent Context Contract","text":"<p>Workers receive what the orchestrator specifies: task description, skill file paths, convention file paths, and scope boundaries. <code>docs/context/agent-rules.md</code> is injected into the orchestrator's session banner; workers receive conventions and skills selected by the orchestrator per-task.</p>"},{"location":"how-it-works/#per-platform-model-configuration","title":"Per-Platform Model Configuration","text":"<p>Worker agent tiers (<code>lore-worker</code>, <code>lore-worker-fast</code>, <code>lore-worker-powerful</code>) and their models are configured via <code>subagentDefaults</code> in <code>.lore/config.json</code> \u2014 not via agent frontmatter. See Configuration: subagentDefaults.</p>"},{"location":"how-it-works/#3-session-acceleration","title":"3. Session Acceleration","text":"<pre><code>flowchart TB\n    subgraph P1[\"Phase 1: Foundation\"]\n        P1a[Explore integrations]\n        P1b[Hit gotchas, create first skills]\n        P1c[\"Heavy discovery cost\"]\n    end\n\n    subgraph P2[\"Phase 2: Specialization\"]\n        P2a[Workers handle delegated tasks]\n        P2b[Context knowledge fills in]\n        P2c[\"Balanced: execute + delegate\"]\n    end\n\n    subgraph P3[\"Phase 3: Full Context\"]\n        P3a[Orchestrator delegates most work]\n        P3b[Full context]\n        P3c[\"Minimal discovery, maximum leverage\"]\n    end\n\n    P1 --&gt; P2 --&gt; P3</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"how-it-works/#context-efficiency","title":"Context Efficiency","text":"<p>Lore uses indirection \u2014 telling the agent where to find things rather than loading everything into context.</p> Layer What It Contains <code>.lore/instructions.md</code> (~115 lines) Framework rules, knowledge routing, naming conventions Session start: framework Operating principles, active agents, active roadmaps/plans Session start: project context Operator customization from <code>docs/context/agent-rules.md</code> Session start: operator profile Identity and preferences from <code>docs/knowledge/local/operator-profile.md</code> (gitignored) Session start: conventions Coding and docs standards from <code>docs/context/conventions/</code> Session start: knowledge map Directory tree of docs/, skills/, and agents/ Session start: local memory Scratch notes from <code>MEMORY.local.md</code> (gitignored) Per-prompt reinforcement Delegation + knowledge discovery + work tracking nudges Post-tool-use reinforcement Capture reminders with escalating urgency Skills and docs Loaded on-demand when invoked or needed <p>When the Docker sidecar is running, the session banner includes a semantic search URL. Agents query by topic to find relevant docs and skills without loading the full directory tree. See Docs UI &amp; Semantic Search.</p> <p>Docs and skills have zero baseline session cost \u2014 they load on-demand. Agents and active roadmaps appear in every session banner but grow slowly in count. See Configuration: Tuning for managing growth.</p>"},{"location":"how-it-works/#hook-architecture","title":"Hook Architecture","text":"<p>Hooks fire at session start, prompt submit, pre-tool-use, post-tool-use, and post-tool-use-failure. Shared logic in <code>lib/</code> keeps behavior consistent across platforms. See Hook Architecture for the full lifecycle, module layout, and platform adapter reference.</p> <p>For limitations and known gaps, see Production Readiness.</p>"},{"location":"production-readiness/","title":"Production Readiness","text":"<p>Lore is pre-1.0 software.</p>"},{"location":"production-readiness/#stability-policy","title":"Stability Policy","text":"<p>Lore follows semantic versioning. During 0.x:</p> <ul> <li>Patch releases (0.8.0 \u2192 0.8.1) \u2014 bug fixes, CI improvements, docs. No breaking changes.</li> <li>Minor releases (0.8.x \u2192 0.9.0) \u2014 new features, new hooks, new lib modules. May include breaking changes to hook output format or config fields. Release notes document what changed and how to migrate.</li> <li><code>/lore-update</code> \u2014 the built-in update command. It syncs framework files (<code>lore-*</code> prefix) while preserving your operator-owned content (skills, agents, docs, conventions).</li> </ul> <p>What can break between minor versions:</p> <ul> <li>Hook output format (the JSON structure hooks emit to agents)</li> <li><code>.lore-config</code> fields (new fields, renamed fields)</li> <li>Script CLI arguments</li> <li>Generated file layout (<code>.claude/</code>, <code>.cursor/rules/</code>, <code>.opencode/</code>)</li> </ul> <p>What won't break:</p> <ul> <li>Your docs (<code>docs/</code>), operator skills, operator agents, conventions</li> <li>The <code>lore-*</code> / non-<code>lore-*</code> ownership boundary</li> <li>Git-tracked knowledge (Lore never deletes operator content)</li> </ul> <p>Post-1.0: minor versions will be non-breaking. Breaking changes will require a major version bump.</p>"},{"location":"production-readiness/#security-and-trust-model","title":"Security and Trust Model","text":""},{"location":"production-readiness/#what-hooks-can-do","title":"What Hooks Can Do","text":"<p>Lore hooks are plain JavaScript files that run as child processes of your coding agent. They have the same permissions as the agent itself \u2014 they can read and write files in your project directory.</p> <p>Hooks do:</p> <ul> <li>Read <code>.lore-config</code>, <code>docs/</code>, <code>.lore/</code>, registry files, and <code>.git/</code> (state files) to build the session banner</li> <li>Write state files to <code>.git/</code> (tracker counters, nav-dirty flags, hook event logs)</li> <li>Write to stdout (injecting context into the agent's conversation)</li> <li>Scaffold sticky files (<code>MEMORY.local.md</code>, <code>.gitignore</code> entries) if missing</li> </ul> <p>Hooks are plain JavaScript child processes scoped to the project directory \u2014 they cannot make network requests, spawn subprocesses, or access files outside the project.</p>"},{"location":"production-readiness/#supply-chain","title":"Supply Chain","text":"<p>Lore has zero npm runtime dependencies. All <code>lib/</code> modules use only Node.js built-ins (<code>fs</code>, <code>path</code>, <code>os</code>, <code>crypto</code>, <code>util</code>). Dev dependencies (eslint, prettier) are not installed by <code>create-lore</code> and do not run in hooks.</p> <p>The installer (<code>create-lore</code>) clones the lore repo at a pinned version tag \u2014 no transitive dependency tree to audit.</p>"},{"location":"production-readiness/#how-to-audit","title":"How to Audit","text":"<p>All hook source is in your repo after install:</p> <pre><code>.lore/hooks/              # Claude Code hooks\n.cursor/hooks/            # Cursor hooks\n.opencode/plugins/        # OpenCode hooks\n.lore/lib/                # Shared logic (all hooks import from here)\n</code></pre> <p>Every file is plain JavaScript with no minification or bundling. Most are under 100 lines; the largest (banner.js) is ~250. Read them directly. The total hook + lib codebase is approximately 1,500 lines.</p> <pre><code># Count all hook and lib code\nwc -l .lore/hooks/*.js .cursor/hooks/*.js .opencode/plugins/*.js .lore/lib/*.js\n</code></pre>"},{"location":"production-readiness/#memorymd-protection","title":"MEMORY.md Protection","text":"<p>Hooks actively block reads and writes to <code>MEMORY.md</code> at the project root. This prevents the agent's platform-level memory feature from overwriting knowledge that should be routed to skills or docs. Access attempts are redirected to <code>MEMORY.local.md</code> (gitignored scratch space) or the appropriate knowledge route.</p>"},{"location":"production-readiness/#known-limitations","title":"Known Limitations","text":"<ul> <li>AI compliance is probabilistic. Hooks inject reminders, not commands. The agent may skip capture in long sessions or under heavy tool use. Running <code>/lore-capture</code> after substantive work improves consistency.</li> <li>Single-developer origin. Lore was built and tested by one developer. The test suite covers hooks, lib modules, and the scaffolder across 3 OSes and 2 Node versions, but edge cases in team workflows are untested.</li> <li>No access control. Anyone with repo access can read and modify all knowledge, skills, and agents. Lore trusts the git permission model.</li> <li>Shell scripts require bash. Core scripts (<code>validate-consistency.sh</code>, <code>generate-nav.sh</code>, etc.) require bash. Windows users need Git Bash, WSL, or equivalent. Hooks themselves are pure Node.js and work everywhere.</li> <li>Context window cost is unmeasured. Hook injections consume tokens from the agent's context window. Measure your own instance with <code>LORE_HOOK_LOG=1</code> \u2014 see Hook Event Logging.</li> </ul>"},{"location":"production-readiness/#non-goals","title":"Non-Goals","text":"<ul> <li>Hosted knowledge storage.</li> <li>Multi-user real-time collaboration.</li> <li>Plugin ecosystem.</li> <li>Model training or fine-tuning.</li> </ul> <p>See When to Use Lore for fit/no-fit guidance.</p>"},{"location":"production-readiness/#ci-and-test-coverage","title":"CI and Test Coverage","text":"<p>All three repos run CI on every push and PR:</p> Repo OSes Node Versions Key Checks lore Ubuntu, macOS, Windows 18, 20 Unit tests, ShellCheck, Prettier, ESLint, npm audit, consistency validation create-lore Ubuntu, macOS, Windows 18, 20 Unit tests, E2E scaffolding, consistency validation lore-docs Ubuntu -- <code>mkdocs build --strict</code>, markdownlint <p>Releases are tag-driven via GitHub Actions. The <code>create-lore</code> release workflow verifies a matching <code>lore</code> tag exists before publishing to npm.</p>"},{"location":"production-readiness/#upgrade-policy","title":"Upgrade Policy","text":"<ol> <li>Check the changelog for breaking changes</li> <li>Run <code>/lore-update</code> from your Lore instance</li> <li>Review the diff \u2014 only <code>lore-*</code> files are touched</li> <li>See Troubleshooting for the full fix-by-symptom table.</li> <li>Commit the update</li> </ol> <p>If something breaks, <code>git checkout</code> the previous state. All changes are local and reversible.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#installation","title":"Installation","text":""},{"location":"troubleshooting/#npx-create-lore-fails-with-could-not-find-remote-branch","title":"<code>npx create-lore</code> fails with \"Could not find remote branch\"","text":"<p>The installer clones a specific version tag from GitHub. If the tag doesn't exist, the clone fails with an error like:</p> <pre><code>fatal: Remote branch vX.Y.Z not found in upstream origin\n</code></pre> <p>Fix: Update to the latest version of create-lore:</p> <pre><code>npx create-lore@latest my-project\n</code></pre> <p>If the problem persists, open an issue.</p>"},{"location":"troubleshooting/#npx-create-lore-fails-with-a-network-error","title":"<code>npx create-lore</code> fails with a network error","text":"<pre><code>fatal: unable to access 'https://github.com/lorehq/lore.git/': Could not resolve host: github.com\n</code></pre> <p>Fix: Check your internet connection and DNS. The installer needs to reach <code>github.com</code> to clone the template. Firewalls, VPNs, and corporate proxies can block git access.</p>"},{"location":"troubleshooting/#node-version-errors","title":"Node version errors","text":"<p>Lore requires Node.js 18 or later.</p> <pre><code>node --version  # must be &gt;= 18\n</code></pre>"},{"location":"troubleshooting/#hooks","title":"Hooks","text":""},{"location":"troubleshooting/#hooks-arent-firing","title":"Hooks aren't firing","text":"<p>Claude Code: Check that <code>.lore/hooks/</code> exists and contains <code>.js</code> files. Run <code>claude</code> from the project root.</p> <p>Cursor: Check that <code>.cursor/hooks.json</code> exists and references files in <code>.cursor/hooks/</code>. Open the project folder directly in Cursor (not a parent directory).</p> <p>OpenCode: Check that <code>opencode.json</code> exists and <code>.opencode/plugins/</code> contains <code>.js</code> files.</p> <p>For all platforms, verify with:</p> <pre><code>bash .lore/scripts/validate-consistency.sh\n</code></pre>"},{"location":"troubleshooting/#memorymd-is-intercepted-warning","title":"\"MEMORY.md is intercepted\" warning","text":"<p>Lore blocks reads and writes to <code>MEMORY.md</code> in the instance root because platform-level memory features overwrite the file between sessions. Use the persistent alternatives:</p> <ul> <li>Scratch notes: <code>MEMORY.local.md</code> (gitignored, survives sessions)</li> <li>Structured knowledge: <code>docs/knowledge/</code> (git-tracked, shared)</li> </ul>"},{"location":"troubleshooting/#escalating-capture-reminders-are-too-aggressive","title":"Escalating capture reminders are too aggressive","text":"<p>The knowledge tracker counts consecutive Bash tool calls without capture and escalates nudges. Configure thresholds in <code>.lore/config.json</code>:</p> <pre><code>{\n  \"nudgeThreshold\": 5,\n  \"warnThreshold\": 10\n}\n</code></pre> <p>Higher values = fewer reminders. See Configuration for details.</p>"},{"location":"troubleshooting/#consistency","title":"Consistency","text":""},{"location":"troubleshooting/#validate-consistencysh-fails","title":"<code>validate-consistency.sh</code> fails","text":"<p>This script runs 11 cross-reference checks. Common failures:</p> Failure Fix Platform copies out of sync <code>bash .lore/scripts/sync-platform-skills.sh</code> Registry stale <code>bash .lore/scripts/generate-registries.sh</code> Nav stale <code>bash .lore/scripts/generate-nav.sh</code> Instructions out of sync <code>bash .lore/scripts/sync-framework.sh</code> (via <code>/lore-update</code>)"},{"location":"troubleshooting/#mkdocsyml-nav-is-stale-after-adding-docs","title":"<code>mkdocs.yml</code> nav is stale after adding docs","text":"<p>The nav is auto-generated. Regenerate it:</p> <pre><code>bash .lore/scripts/generate-nav.sh\n</code></pre>"},{"location":"troubleshooting/#updates","title":"Updates","text":""},{"location":"troubleshooting/#lore-update-shows-conflicts","title":"<code>/lore-update</code> shows conflicts","text":"<p><code>/lore-update</code> only touches framework-owned files (<code>lore-*</code> prefix). If you see conflicts, you may have modified a <code>lore-*</code> file directly. Framework files are overwritten on sync \u2014 move your changes to an operator-owned file (no <code>lore-</code> prefix).</p>"},{"location":"troubleshooting/#version-mismatch-after-update","title":"Version mismatch after update","text":"<p>Check that <code>.lore/config.json</code> and <code>package.json</code> agree:</p> <pre><code>bash .lore/scripts/check-version-sync.sh\n</code></pre> <p>If they diverge, the update didn't complete cleanly. Run <code>/lore-update</code> again.</p>"},{"location":"troubleshooting/#still-stuck","title":"Still Stuck?","text":"<ul> <li>Check the guides for detailed walkthroughs</li> <li>Open an issue with reproduction steps</li> <li>For security issues, see SECURITY.md</li> </ul>"},{"location":"when-to-use-lore/","title":"When to Use Lore","text":""},{"location":"when-to-use-lore/#good-fit","title":"Good Fit","text":"<p>You work with coding agents regularly and notice them rediscovering the same things.</p> <ul> <li>You've explained your project's auth quirks, deployment process, or API patterns to the agent more than once</li> <li>You have a growing project where context matters \u2014 service relationships, config conventions, infrastructure details</li> <li>You want the agent to get better over time without manual prompt engineering</li> </ul> <p>You use multiple repos or services that share context.</p> <ul> <li>The agent needs to know about your infrastructure, CI setup, or cross-repo relationships</li> <li>You link work repos to a central Lore instance so every project benefits from shared knowledge</li> </ul> <p>You want structured work tracking inside the agent's workflow.</p> <ul> <li>Roadmaps and plans that survive session boundaries</li> <li>The agent sees active work items at startup and picks up where it left off</li> </ul>"},{"location":"when-to-use-lore/#poor-fit","title":"Poor Fit","text":"<p>Your projects are short-lived or disposable.</p> <ul> <li>One-off scripts, throwaway prototypes, hackathon projects \u2014 the knowledge capture overhead isn't worth it when there's no \"next session\" to benefit from</li> </ul> <p>You don't use coding agents.</p> <ul> <li>Lore is specifically for AI coding agents (Claude Code, Cursor, OpenCode). It has no value without one.</li> </ul> <p>You need team-wide real-time collaboration.</p> <ul> <li>Lore is single-agent, single-user. Team workflows use git (branches, PRs, merges). There's no live sync, no conflict resolution beyond git, no multi-user access control.</li> </ul> <p>Your environment prohibits local file writes.</p> <ul> <li>Lore stores everything as files in your git repo. Sandboxed environments, read-only containers, or restricted CI runners won't work.</li> </ul>"},{"location":"when-to-use-lore/#team-workflows","title":"Team Workflows","text":"<p>See Cross-Repo Workflow for team topology options.</p>"},{"location":"when-to-use-lore/#comparison-with-alternatives","title":"Comparison With Alternatives","text":"Approach Persistent? Structured? Agent-integrated? MEMORY.md (platform built-in) Partial \u2014 platforms overwrite between sessions No \u2014 free-form text blob Yes CLAUDE.md / .cursorrules Yes \u2014 git-tracked Minimal \u2014 single file Yes Custom system prompts Yes \u2014 but manual maintenance Your structure Depends on platform Lore Yes \u2014 git-tracked, multi-file Yes \u2014 skills, agents, docs, conventions Yes \u2014 hooks reinforce capture <p>Lore's main value over simpler approaches is compounding structure. A <code>CLAUDE.md</code> file works fine at 50 lines. At 500 lines it becomes a wall of text the agent skims past. Lore routes knowledge to the right location (skill, doc, convention, runbook) and loads it on demand instead of dumping everything into every session. For measured cost data, see Cost Evidence.</p>"},{"location":"when-to-use-lore/#migration","title":"Migration","text":""},{"location":"when-to-use-lore/#from-claudemd-cursorrules","title":"From CLAUDE.md / .cursorrules","text":"<ol> <li>Install Lore: <code>npx create-lore my-project</code></li> <li>Move project-specific rules to <code>docs/context/agent-rules.md</code></li> <li>Move coding conventions to <code>docs/context/conventions/</code></li> <li>Move gotchas and tricks to skills via <code>/lore-create-skill</code></li> <li>Move environment details (URLs, services, relationships) to <code>docs/knowledge/environment/</code></li> <li>Delete the old file \u2014 Lore generates <code>CLAUDE.md</code> from <code>.lore/instructions.md</code></li> </ol>"},{"location":"when-to-use-lore/#from-scratch-notes-no-system","title":"From Scratch Notes / No System","text":"<ol> <li>Install Lore: <code>npx create-lore my-project</code></li> <li>Work normally. Hooks will nudge the agent to capture knowledge as it discovers things.</li> <li>Run <code>/lore-capture</code> after substantive sessions to ensure nothing was missed.</li> <li>Knowledge accumulates naturally. Review <code>docs/</code> periodically to prune noise.</li> </ol>"},{"location":"when-to-use-lore/#uninstalling","title":"Uninstalling","text":"<p>Lore is just files. Delete the Lore directories and you're back to a normal project:</p> <pre><code>rm -rf .lore .claude .cursor .opencode hooks lib scripts\nrm CLAUDE.md opencode.json mkdocs.yml .lore-config\n</code></pre> <p>Your <code>docs/</code> directory contains your accumulated knowledge \u2014 keep it or delete it. Nothing external to clean up. No accounts, no services, no subscriptions.</p>"},{"location":"assets/","title":"Assets","text":"<p>Static assets for the docs site (logo, stylesheets).</p>"},{"location":"context/","title":"Context","text":"<p>The <code>context/</code> directory holds files that are injected into every agent session as project context. <code>agent-rules.md</code> describes the project and sets agent behavior constraints; the <code>conventions/</code> subdirectory holds coding and documentation standards. Together these files ensure the agent has consistent grounding before your first prompt.</p> <ul> <li>Agent Rules</li> <li>Conventions</li> </ul>"},{"location":"context/agent-rules/","title":"Agent Rules","text":""},{"location":"context/agent-rules/#about","title":"About","text":"<p>Describe your project and key constraints.</p>"},{"location":"context/agent-rules/#agent-behavior","title":"Agent Behavior","text":"<p>Rules for how the agent should operate in this instance.</p>"},{"location":"context/conventions/","title":"Conventions","text":"<p>The <code>conventions/</code> directory holds coding and documentation standards that are injected into every agent session alongside <code>agent-rules.md</code>. Add a file here for each convention set you want the agent to follow consistently \u2014 language style, file naming, commit format, or any other project-wide rules.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/brainstorm/","title":"Example Brainstorm","text":"<p>Brainstorms capture exploratory discussions, architectural decisions, and design trade-offs for future reference. They document thinking \u2014 not work progress. Each brainstorm serves as a decision record: options considered, trade-offs, and rationale. Ask Lore to create one \u2014 for example: \"Start a brainstorm about auth options.\" Lore handles the folder structure and frontmatter.</p>"},{"location":"examples/brainstorm/#template","title":"Template","text":"<p>File: <code>docs/work/brainstorms/&lt;slug&gt;/index.md</code></p> <pre><code>---\ntitle: &lt;Topic&gt;\ncreated: 2026-01-10\n---\n</code></pre> <pre><code># &lt;Topic&gt;\n\n## Context\n\n&lt;What prompted this discussion. Key questions to answer.&gt;\n\n## Approaches Considered\n\n### Option 1: &lt;Name&gt;\n\n**Approach:** &lt;How it works.&gt;\n\n**Pros:**\n- &lt;Advantage&gt;\n- &lt;Advantage&gt;\n\n**Cons:**\n- &lt;Disadvantage&gt;\n- &lt;Disadvantage&gt;\n\n**Effort:** &lt;Estimate&gt;\n\n---\n\n### Option 2: &lt;Name&gt;\n\n**Approach:** &lt;How it works.&gt;\n\n**Pros:**\n- &lt;Advantage&gt;\n- &lt;Advantage&gt;\n\n**Cons:**\n- &lt;Disadvantage&gt;\n- &lt;Disadvantage&gt;\n\n**Effort:** &lt;Estimate&gt;\n\n## Recommended Approach\n\n**Selected:** &lt;Option name&gt;\n\n**Rationale:**\n- &lt;Why this option&gt;\n- &lt;Key factors&gt;\n\n## Decision\n\n&lt;Clear statement of what was decided and first steps.&gt;\n\n## Follow-Up\n\nThis brainstorm informed:\n- [&lt;Roadmap or Plan Name&gt;](../path/to/index.md)\n</code></pre>"},{"location":"examples/brainstorm/#see-also","title":"See Also","text":"<ul> <li>Example Roadmap</li> <li>Example Plan</li> <li>Roadmaps &amp; Plans Guide</li> </ul>"},{"location":"examples/plan/","title":"Example Plan","text":""},{"location":"examples/plan/#template","title":"Template","text":"<p>File: <code>docs/work/plans/&lt;slug&gt;/index.md</code></p> <pre><code>---\ntitle: &lt;Plan Name&gt;\nstatus: active\ncreated: 2026-02-01\nupdated: 2026-02-06\nsummary: &lt;one-liner shown in session banner&gt;\ntarget: 2026-02-28\n---\n</code></pre> <pre><code># &lt;Plan Name&gt;\n\n## Goal\n\n&lt;1-2 sentences: what this plan accomplishes.&gt;\n\n## Context\n\n&lt;Why this work is needed. Link to parent roadmap if applicable.&gt;\n\n## Approach\n\n### 1. &lt;Step Name&gt;\n\n&lt;What to do, technical details, configuration.&gt;\n\n### 2. &lt;Step Name&gt;\n\n&lt;What to do, decisions made, rationale.&gt;\n\n### 3. &lt;Step Name&gt;\n\n&lt;What to do, dependencies, expected output.&gt;\n\n## Implementation Steps\n\n1. &lt;Completed step&gt;\n2. &lt;In progress step&gt;\n3. &lt;Pending step&gt;\n4. &lt;Pending step&gt;\n\n## Test Plan\n\n- [ ] &lt;Verification step&gt;\n- [ ] &lt;Verification step&gt;\n- [ ] &lt;Performance target&gt;\n\n## Success Criteria\n\n- &lt;Measurable outcome&gt;\n- &lt;Measurable outcome&gt;\n\n## Blockers\n\nNone currently.\n\n## Notes\n\n&lt;Decisions, caveats, things to revisit later.&gt;\n</code></pre> <p>See Roadmaps &amp; Plans for status workflow, archiving, and hierarchy.</p>"},{"location":"examples/plan/#see-also","title":"See Also","text":"<ul> <li>Roadmaps &amp; Plans Guide</li> <li>Example Roadmap</li> <li>Example Brainstorm</li> </ul>"},{"location":"examples/roadmap/","title":"Example Roadmap","text":""},{"location":"examples/roadmap/#template","title":"Template","text":"<p>File: <code>docs/work/roadmaps/&lt;slug&gt;/index.md</code></p> <pre><code>---\ntitle: &lt;Initiative Name&gt;\nstatus: active\ncreated: 2026-01-15\nupdated: 2026-02-06\nphase: 2/3\nsummary: &lt;Current phase name&gt;\ntarget: 2026-06-30\n---\n</code></pre> <pre><code># &lt;Initiative Name&gt;\n\n## Overview\n\n&lt;1-2 sentences: what this initiative accomplishes and why.&gt;\n\n## Phases\n\n### Phase 1: &lt;Name&gt;\n**Status:** Completed (2026-01-15 to 2026-01-31)\n- &lt;Completed deliverable&gt;\n- &lt;Completed deliverable&gt;\n\n### Phase 2: &lt;Name&gt;\n**Status:** In Progress (2026-02-01 to 2026-03-31)\n- &lt;Work item&gt;\n- &lt;Work item&gt;\n\n**Plans:**\n- [&lt;Plan Name&gt;](plans/&lt;slug&gt;/index.md)\n\n### Phase 3: &lt;Name&gt;\n**Status:** Planned (2026-04-01 to 2026-06-30)\n- &lt;Work item&gt;\n- &lt;Work item&gt;\n\n## Success Criteria\n\n- &lt;Measurable outcome&gt;\n- &lt;Measurable outcome&gt;\n\n## Risks\n\n| Risk | Mitigation |\n|------|------------|\n| &lt;What could go wrong&gt; | &lt;How to prevent or recover&gt; |\n</code></pre> <p>See Roadmaps &amp; Plans for status workflow, archiving, and hierarchy.</p>"},{"location":"examples/roadmap/#see-also","title":"See Also","text":"<ul> <li>Roadmaps &amp; Plans Guide</li> <li>Example Plan</li> <li>Example Brainstorm</li> </ul>"},{"location":"examples/skill/","title":"Example Skill","text":"<p>Skills capture gotchas \u2014 workarounds, parameter tricks, and auth quirks that aren't obvious from docs alone.</p>"},{"location":"examples/skill/#template","title":"Template","text":"<p>File: <code>.lore/skills/&lt;name&gt;/SKILL.md</code></p> <pre><code>---\nname: &lt;service&gt;-&lt;action&gt;-&lt;object&gt;\ndescription: &lt;one-line summary of the gotcha&gt;\nuser-invocable: false\nallowed-tools: Bash, Read, etc\n---\n</code></pre> <pre><code># &lt;Title&gt;\n\n&lt;Brief explanation of the problem.&gt;\n\n## The Gotcha\n\n&lt;What goes wrong and why.&gt;\n\n## Solution\n\n&lt;The fix, workaround, or correct approach.&gt;\n\n## Detection\n\n&lt;How to spot this issue before it causes problems.&gt;\n</code></pre>"},{"location":"examples/skill/#real-example","title":"Real Example","text":"<p>This skill was captured after discovering that macOS ships Bash 3.2 and common Bash 4+ features silently break:</p> <pre><code>---\nname: bash-macos-compat\ndescription: Avoid Bash 4+ features that break on macOS stock Bash 3.2\nuser-invocable: false\nallowed-tools: Bash, Read\n---\n</code></pre> <pre><code># Bash macOS Compatibility\n\nmacOS ships Bash 3.2 (2007). These features require Bash 4+ and will break:\n\n## Broken on Bash 3.2\n\n| Feature | Bash 4+ | Portable Alternative |\n|---------|---------|---------------------|\n| Associative arrays | `declare -A map` | Pipe-delimited string + `case` |\n| Lowercase transform | `${var,,}` | `echo \"$var\" | tr '[:upper:]' '[:lower:]'` |\n| Key existence test | `[[ -v arr[key] ]]` | `case` pattern match |\n\n## Pattern: Associative Array Replacement\n\nInstead of:\n\n    declare -A existing\n    existing[\"${key,,}\"]=1\n\nUse delimited strings:\n\n    existing=\"|\"\n    existing=\"${existing}$(echo \"$key\" | tr '[:upper:]' '[:lower:]')|\"\n    case \"$existing\" in *\"|$lookup|\"*) echo \"found\" ;; esac\n\n## Detection\n\ngrep for `declare -A`, `${.*,,}`, `[[ -v`, `readarray` before shipping.\n</code></pre>"},{"location":"examples/skill/#see-also","title":"See Also","text":"<ul> <li>Example Plan</li> <li>Example Roadmap</li> <li>Example Brainstorm</li> </ul>"},{"location":"guides/","title":"Guides","text":""},{"location":"guides/configuration/","title":"Configuration","text":"<p>Lore reads settings from <code>.lore/config.json</code> (JSON) at the instance root and from environment variables.</p>"},{"location":"guides/configuration/#loreconfigjson","title":"<code>.lore/config.json</code>","text":"<pre><code>{\n  \"version\": \"1.0.0\",\n  \"treeDepth\": 5,\n  \"nudgeThreshold\": 3,\n  \"warnThreshold\": 5,\n  \"profile\": \"standard\"\n}\n</code></pre>"},{"location":"guides/configuration/#fields","title":"Fields","text":"Field Type Default Description <code>version</code> string -- Displayed in the session banner (<code>=== LORE v1.0.0 ===</code>) <code>treeDepth</code> number <code>5</code> Max directory depth in the knowledge map tree <code>nudgeThreshold</code> number <code>3</code> Bash commands before a gentle capture reminder <code>warnThreshold</code> number <code>5</code> Bash commands before a strong capture warning <code>profile</code> string <code>\"standard\"</code> Hook behavior profile. See Hook Profile. <p>All fields are optional. Missing fields fall back to defaults. If <code>.lore/config.json</code> is missing or contains a parse error, all fields silently fall back to defaults \u2014 no error is thrown.</p> <p>Metadata fields \u2014 <code>name</code> and <code>created</code> are informational, set during instance creation. Not used by framework logic.</p>"},{"location":"guides/configuration/#subagentdefaults","title":"<code>subagentDefaults</code>","text":"<p>Controls which worker agent tiers are generated and which model each tier uses in Claude Code.</p> <pre><code>{\n  \"subagentDefaults\": {\n    \"claude\": {\n      \"fast\": \"claude-haiku-4-5\",\n      \"default\": \"claude-sonnet-4-5\",\n      \"powerful\": \"claude-opus-4-5\"\n    }\n  }\n}\n</code></pre> <p><code>subagentDefaults.claude</code> accepts up to three tier keys:</p> Key Generated agent Description <code>default</code> <code>lore-worker</code> (always generated) Standard worker. Uses <code>claude.default</code> model if set; omits model field otherwise (platform picks its own default). <code>fast</code> <code>lore-worker-fast</code> (only when key is set) Lightweight worker for cheap, parallelizable tasks. <code>powerful</code> <code>lore-worker-powerful</code> (only when key is set) High-capability worker for complex reasoning tasks. <p><code>lore-worker</code> is always generated by <code>sync-platform-skills.sh</code>. <code>lore-worker-fast</code> and <code>lore-worker-powerful</code> are only generated when their respective tier key is present in the config.</p> <p>Model values use vendor-native identifiers \u2014 no translation is performed.</p>"},{"location":"guides/configuration/#hook-profile","title":"Hook Profile","text":"<p>Controls which hook behaviors are active for the session.</p> <pre><code>{\n  \"profile\": \"discovery\"\n}\n</code></pre> <p>Any unrecognized value (or a missing <code>profile</code> key) falls back to <code>standard</code>.</p> Value Behavior <code>standard</code> Default. All hooks active. Capture nudges at normal thresholds. <code>minimal</code> Per-tool nudges off. Session banner notes to use <code>/lore-capture</code> manually. Use when hooks feel noisy. <code>discovery</code> All hooks active. Banner adds aggressive capture instructions for environment mapping and skill creation. Use during initial setup or unfamiliar codebase exploration."},{"location":"guides/configuration/#tuning-for-large-instances","title":"Tuning for Large Instances","text":"<p>The largest contributor to session banner size is the knowledge map \u2014 a directory-only tree of <code>docs/</code>, <code>skills/</code>, and <code>agents/</code>. Size grows with the number of directories, not documents.</p> <p><code>treeDepth</code> limits how many directory levels the knowledge map displays. Default is 5. Reducing to 3 or 4 hides deep nesting while showing top-level structure.</p> <p>When to act:</p> <ul> <li>Knowledge map exceeds ~50 lines \u2192 reduce <code>treeDepth</code> or reorganize subdirectories</li> <li><code>MEMORY.local.md</code> exceeds ~50 lines \u2192 route content to skills or <code>docs/knowledge/</code></li> <li>Conventions section growing \u2192 keep it focused on rules, move reference material to <code>docs/knowledge/</code></li> <li>Many active work items \u2192 archive completed items with <code>/lore-capture</code></li> </ul> <p>Archived items (in <code>archive/</code> subdirectories) are excluded from the knowledge map tree \u2014 they do not appear in the session banner. This keeps the map focused on active content.</p>"},{"location":"guides/configuration/#environment-variables","title":"Environment Variables","text":"Variable Description <code>LORE_DEBUG=1</code> Enable debug logging to stderr <code>LORE_HOOK_LOG=1</code> Enable structured hook event logging to <code>.git/lore-hook-events.jsonl</code> <code>LORE_HUB</code> Internal. Set by <code>/lore-link</code> to point cross-repo hooks back to the hub"},{"location":"guides/configuration/#hook-event-logging","title":"Hook Event Logging","text":"<p><code>LORE_HOOK_LOG</code> enables structured event logging for all hooks across all three platforms. Each hook fire writes a JSON line to <code>.git/lore-hook-events.jsonl</code>. Zero cost when disabled.</p> <pre><code>export LORE_HOOK_LOG=1\n</code></pre> <p>Each entry records:</p> <pre><code>{\"ts\": 1740000000000, \"platform\": \"cursor\", \"hook\": \"capture-nudge\", \"event\": \"beforeShellExecution\", \"output_size\": 52, \"state\": {\"bash\": 3}}\n</code></pre> Field Description <code>ts</code> Unix epoch milliseconds <code>platform</code> <code>claude</code>, <code>cursor</code>, or <code>opencode</code> <code>hook</code> Hook filename (e.g., <code>capture-nudge</code>, <code>session-init</code>) <code>event</code> Platform event name (e.g., <code>beforeShellExecution</code>, <code>PostToolUse</code>) <code>output_size</code> Characters injected into the agent's context (0 for silent hooks) <code>state</code> Optional hook-specific snapshot (bash counter, flags) <p>Analyze collected data:</p> <pre><code>bash .lore/scripts/analyze-hook-logs.sh\n</code></pre> <p>The report shows fires per platform, fires per hook, average output sizes, estimated accumulated context tokens, and any hooks that never fired. To reset: <code>rm .git/lore-hook-events.jsonl</code>.</p>"},{"location":"guides/conventions/","title":"Conventions","text":"<p>Conventions are behavioral rules that shape how your agent writes code, docs, and knowledge entries. They live in <code>docs/context/conventions/</code> as markdown files \u2014 one file per domain.</p>"},{"location":"guides/conventions/#how-they-work","title":"How They Work","text":"<p>Conventions reach your agent through four channels:</p> <ol> <li>Session start \u2014 all convention files load into the session banner at session start.</li> <li>Per-prompt reminder \u2014 a hook lists convention names before every user message (e.g. <code>Conventions: coding, docs, security</code>).</li> <li>Write-time reinforcement \u2014 a guard fires before every file write or edit, injecting relevant convention principles based on the target path.</li> <li>Agent initiative \u2014 the agent can read any convention file at any time.</li> </ol> <p>The guard reads bold principle lines (<code>**Like this.**</code>) from the convention files.</p>"},{"location":"guides/conventions/#path-based-routing","title":"Path-Based Routing","text":"Target path Conventions injected Any file in the repo Security <code>docs/</code> Security + Docs <code>docs/work/</code> Security + Docs + Work Items <code>docs/knowledge/</code> Security + Docs + Knowledge Capture <p>After injecting matched conventions, the guard lists remaining conventions as a menu so the agent can self-serve those that aren't path-matched.</p>"},{"location":"guides/conventions/#platform-support","title":"Platform Support","text":"Platform Mechanism Automatic? Claude Code PreToolUse hook on Write/Edit Yes OpenCode ESM plugin on <code>tool.execute.before</code> Yes Cursor MCP tool <code>lore_write_guard</code> Agent-initiated (instructed by cursor rule)"},{"location":"guides/conventions/#default-conventions","title":"Default Conventions","text":"<p>Every new Lore instance ships with five conventions:</p> Convention What it corrects Coding Over-engineering, speculative features, unrelated changes, unverified work Docs Duplication, sprawl, doc rot, unsolicited docs, vague references Knowledge Capture Scattered facts, one-page-per-tiny-thing proliferation, high update cost Security Secrets in version control, excessive privileges, missing boundary validation Work Items Inconsistent formatting in plans, roadmaps, and brainstorms"},{"location":"guides/conventions/#creating-custom-conventions","title":"Creating Custom Conventions","text":"<p>Add a markdown file to <code>docs/context/conventions/</code>:</p> <pre><code># Diagrams\n\n## 1. Keep Diagrams as Code\n\n**Mermaid over images. Text over binaries.**\n\n- Use Mermaid syntax for flowcharts, sequence diagrams, and architecture views.\n- Only use image files when the diagram can't be expressed as code.\n- Store diagram source alongside the rendered output.\n\n## 2. Label Everything\n\n**Unlabeled boxes are unlabeled confusion.**\n\n- Every node, edge, and swimlane gets a descriptive label.\n- Use consistent naming with the codebase (service names, API names).\n</code></pre>"},{"location":"guides/conventions/#format-requirements","title":"Format Requirements","text":"<ul> <li>Bold principle lines (<code>**Like this.**</code>) are what the write-time guard extracts and injects. Make them concise and actionable.</li> <li>Numbered sections help scanning. Match the pattern of the default conventions.</li> <li>File name becomes the menu label. Use descriptive kebab-case: <code>api-design.md</code>, <code>email-drafting.md</code>, <code>diagrams.md</code>. The agent uses the file name to decide whether to load the convention, so prefer self-explanatory names (<code>email-drafting.md</code>) over vague ones (<code>comms.md</code>).</li> </ul> <p>Default conventions have hardcoded path routing \u2014 their bold principles are injected automatically before writes to matching paths. Custom conventions appear as a menu listing at write-time.</p>"},{"location":"guides/cross-repo-workflow/","title":"Working Across Repos","text":"<p>Lore is designed as a hub \u2014 one Lore instance that tracks and performs work across all your other repositories.</p>"},{"location":"guides/cross-repo-workflow/#how-it-works","title":"How It Works","text":"<pre><code>flowchart TD\n    Lore[\"Lore Instance&lt;br/&gt;(knowledge hub)\"]\n    Lore --&gt;|work on| A[\"app-api/\"]\n    Lore --&gt;|work on| B[\"app-frontend/\"]\n    Lore --&gt;|work on| C[\"infra/\"]\n\n    A --&gt;|knowledge flows back| Lore\n    B --&gt;|knowledge flows back| Lore\n    C --&gt;|knowledge flows back| Lore</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom  <ol> <li> <p>Connect your agent to the Lore instance. CLI agents launch from here directly. IDE agents use <code>lore link</code> to work from the code repo with hooks firing from the hub.</p> </li> <li> <p>Work on other repos. The agent reads, writes, and runs commands across repos using absolute paths.</p> <pre><code>\"Fix the auth bug in ~/projects/app-api\"\n\"Run the tests in ~/projects/app-frontend\"\n\"Update the Terraform config in ~/projects/infra\"\n</code></pre> </li> <li> <p>Knowledge captures back to Lore. Gotchas become skills, endpoints go to context docs, multi-step procedures become runbooks \u2014 all stored in the Lore instance, available next session.</p> </li> </ol>"},{"location":"guides/cross-repo-workflow/#what-crosses-repo-boundaries","title":"What Crosses Repo Boundaries","text":"<p>The agent operates on files and commands anywhere on your machine. There's no path restriction.</p> Operation How it works Read/write files Absolute paths (<code>/home/you/projects/app-api/src/auth.ts</code>) Git operations <code>git -C /path/to/repo status</code>, <code>git -C /path/to/repo commit ...</code> Run tests <code>cd /path/to/repo &amp;&amp; npm test</code> Search code Grep/Glob with path parameter pointing at any directory"},{"location":"guides/cross-repo-workflow/#what-stays-in-lore","title":"What Stays in Lore","text":"Artifact Example Skills \"This API requires case-sensitive org names\" Knowledge docs Repo inventory, service endpoints, relationships Runbooks \"How to deploy app-api to staging\" Roadmaps/plans Work that spans multiple repos <p>None of this pollutes your work repos.</p>"},{"location":"guides/cross-repo-workflow/#two-workflows","title":"Two Workflows","text":"<p>Choose based on your agent and tooling:</p> <p>CLI agents (Claude Code, OpenCode): Launch from the Lore instance. This loads instructions, hooks, and accumulated knowledge. Then reference any other repo by path.</p> <pre><code>cd ~/projects/my-lore-project\nclaude       # Claude Code\nopencode     # OpenCode\n</code></pre> <p>IDE agents (Cursor): Use <code>lore link</code> to work from your code repo. You keep full file tree, git integration, and search \u2014 hooks still fire from the hub.</p>"},{"location":"guides/cross-repo-workflow/#ide-workflow-lore-link","title":"IDE Workflow: lore link","text":""},{"location":"guides/cross-repo-workflow/#usage","title":"Usage","text":"<pre><code>/lore-link ~/projects/my-app          # Link a work repo\n/lore-link --unlink ~/projects/my-app  # Remove the link\n/lore-link --list                       # Show linked repos (with stale detection)\n/lore-link --refresh                    # Regenerate configs in all linked repos\n</code></pre>"},{"location":"guides/cross-repo-workflow/#what-it-generates","title":"What It Generates","text":"<p>In the target repo, <code>/lore-link</code> creates:</p> <ul> <li>Claude Code \u2014 <code>.claude/settings.json</code> with hooks pointing to the hub</li> <li>Cursor \u2014 <code>.cursor/hooks.json</code> + <code>.cursor/mcp.json</code> + <code>.cursor/rules/lore-*.mdc</code> pointing to the hub</li> <li>OpenCode \u2014 <code>.opencode/plugins/</code> wrappers (3 of 5 hub plugins: session-init, protect-memory, knowledge-tracker) + <code>.opencode/commands/</code> + <code>opencode.json</code> pointing to the hub</li> <li>Instructions \u2014 <code>CLAUDE.md</code> rewritten from hub's <code>.lore/instructions.md</code></li> <li>Marker \u2014 <code>.lore</code> file recording the hub path and link timestamp</li> </ul> <p>All generated files are added to the target repo's <code>.gitignore</code> automatically. Existing files are backed up with a <code>.bak</code> extension before overwriting.</p>"},{"location":"guides/cross-repo-workflow/#knowledge-still-centralizes","title":"Knowledge Still Centralizes","text":"<p>Even when working from a linked repo, knowledge captures back to the hub. Skills, context docs, and runbooks all write to the hub directory \u2014 the work repo stays clean.</p>"},{"location":"guides/cross-repo-workflow/#when-to-use-which","title":"When to Use Which","text":"Scenario Approach CLI agent (Claude Code, OpenCode) Launch from the Lore instance IDE agent (Cursor, or IDE-mode Claude Code) lore link \u2014 link the work repo, open it in your IDE Quick cross-repo task from the hub Launch from the Lore instance, reference the path"},{"location":"guides/cross-repo-workflow/#after-framework-updates","title":"After Framework Updates","text":"<p>Run <code>/lore-link --refresh</code> after <code>/lore-update</code> to regenerate configs in all linked repos with the latest hooks.</p>"},{"location":"guides/cross-repo-workflow/#team-topologies","title":"Team Topologies","text":"<p>Lore is designed for individual operators with coding agents, but teams can adopt it.</p>"},{"location":"guides/cross-repo-workflow/#one-instance-per-developer","title":"One Instance Per Developer","text":"<p>Each developer maintains their own Lore instance. Knowledge captures reflect individual discoveries. Sharing happens through git \u2014 push your instance, teammates pull useful skills or docs into theirs.</p> <p>Pros: No conflicts, each developer's agent captures their patterns. Cons: Knowledge doesn't automatically propagate across the team.</p>"},{"location":"guides/cross-repo-workflow/#shared-instance","title":"Shared Instance","text":"<p>The team shares a single Lore instance in a dedicated repo. Everyone commits knowledge to the same <code>docs/</code> and <code>.lore/skills/</code>. Standard git workflow applies \u2014 branches, PRs, code review.</p> <p>Pros: Knowledge compounds across the whole team. New members benefit from day one. Cons: Merge conflicts in docs. Capture conventions need team agreement. More noise in the knowledge base.</p>"},{"location":"guides/cross-repo-workflow/#hub-per-team-link-per-repo","title":"Hub Per Team, Link Per Repo","text":"<p>A team maintains one Lore hub with shared knowledge. Each developer uses <code>/lore-link</code> to connect their work repos to the hub. The hub holds skills, conventions, and context. Work repos get hooks that point back to the hub.</p> <p>Pros: Centralized knowledge, decentralized work. Each repo stays clean. Cons: Hub maintenance is a team responsibility. Breaking changes in the hub affect all linked repos.</p>"},{"location":"guides/docs-ui/","title":"Docs UI &amp; Semantic Search","text":"<p>A single Docker container that runs locally alongside the agent, providing semantic search over your knowledge base and a live-reloading docs site.</p>"},{"location":"guides/docs-ui/#what-you-get","title":"What You Get","text":""},{"location":"guides/docs-ui/#semantic-search","title":"Semantic Search","text":"<p>A local HTTP API that indexes all knowledge files, skills, work items, and agents. Agents query by topic or meaning \u2014 not just filename \u2014 and get back ranked file paths. Hooks use the API automatically when the container is running.</p> <p>Without Docker, agents fall back to Grep/Glob (keyword search). That works fine for small knowledge bases and degrades as content grows.</p>"},{"location":"guides/docs-ui/#mkdocs-ui","title":"MkDocs UI","text":"<p>A live-reloading site at <code>localhost:PORT</code> that renders your full knowledge base as a browsable site. Useful for seeing exactly what the agent sees, verifying conventions, and navigating large knowledge bases without opening individual files.</p>"},{"location":"guides/docs-ui/#setup","title":"Setup","text":"<p>Prerequisite: Docker (Docker Desktop or Docker Engine).</p> <pre><code>/lore-docker          # start\n/lore-docker stop     # stop\n/lore-docker status   # health check\n</code></pre> <p>On first start, Docker pulls the image (<code>lorehq/lore-docker:latest</code>) and loads the semantic models \u2014 allow 1\u20133 minutes. The docs site comes up first; semantic search becomes available once model loading completes (~30\u201360s after the site is up). Subsequent starts are fast \u2014 image and volumes are cached.</p>"},{"location":"guides/docs-ui/#ports-configuration","title":"Ports &amp; Configuration","text":"<p>Ports are auto-computed per project (hash of project name, range 9001\u20139999) so multiple projects never collide. Semantic search runs on docs port + 1000.</p> <p>Override in <code>.lore/config.json</code>:</p> <pre><code>{\n  \"docker\": {\n    \"site\":   { \"port\": 9010 },\n    \"search\": { \"port\": 10010 }\n  }\n}\n</code></pre> <p><code>/lore-docker start</code> writes the resolved ports to <code>.lore/config.json</code> automatically after the first successful start.</p>"},{"location":"guides/docs-ui/#without-docker","title":"Without Docker","text":"<p>Agents fall back to Grep/Glob silently \u2014 no configuration needed. The fallback works reliably for small-to-medium knowledge bases. If queries start missing relevant content or you want the visual docs site, start the container.</p>"},{"location":"guides/docs-ui/#when-to-start-the-sidecar","title":"When to Start the Sidecar","text":"<p>Start it at project setup and leave it running. Semantic search improves knowledge retrieval as your docs grow \u2014 the value compounds over time. For a brand-new project with minimal docs, Grep/Glob fallback is fine. Once you have more than a few dozen knowledge files, the sidecar pays for itself in retrieval quality.</p>"},{"location":"guides/docs-ui/#gotchas","title":"Gotchas","text":"<ul> <li>Model loading takes 30\u201360s on first start. The docs site appears before semantic search is ready. <code>/lore-docker status</code> reports semantic search health separately from site health.</li> <li>During bulk file edits, the file watcher may crash (editor temp files cause a race condition). Restart the container after bulk edits complete.</li> <li>The container creates a named Docker volume per project for the search index. First start triggers a full index build; subsequent starts are fast.</li> </ul>"},{"location":"guides/hook-architecture/","title":"Hook Architecture","text":"<p>Lore hooks into the agent's lifecycle at seven events. Shared logic lives in <code>lib/</code>, with thin adapters for each platform.</p>"},{"location":"guides/hook-architecture/#hook-lifecycle","title":"Hook Lifecycle","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Agent\n    participant Hooks\n    participant KB as Knowledge Base\n\n    Note over Hooks: SessionStart\n    Hooks-&gt;&gt;KB: ensureStickyFiles()\n    Hooks-&gt;&gt;KB: Read agent-rules, conventions, work items\n    Hooks-&gt;&gt;Agent: Inject session banner\n\n    loop Every Prompt\n        User-&gt;&gt;Agent: Message\n        Note over Hooks: UserPromptSubmit\n        Hooks-&gt;&gt;Agent: Knowledge discovery + work tracking reminder\n        Agent-&gt;&gt;Agent: Work (tool calls)\n\n        Note over Hooks: PreToolUse\n        Hooks-&gt;&gt;Agent: Memory guard (block MEMORY.md)\n        Hooks-&gt;&gt;Agent: Context path guide (show tree)\n\n        Note over Hooks: PostToolUse\n        Hooks-&gt;&gt;Agent: Capture reminder (escalating)\n        Hooks-&gt;&gt;Hooks: Set nav-dirty flag if docs/ changed\n    end</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"guides/hook-architecture/#module-layout","title":"Module Layout","text":"<pre><code>flowchart TB\n    subgraph lib[\".lore/lib/ (shared core)\"]\n        banner[\"banner.js&lt;br/&gt;Banner assembly\"]\n        tree[\"tree.js&lt;br/&gt;ASCII tree builder\"]\n        config[\"config.js&lt;br/&gt;Config reader\"]\n        sticky[\"sticky.js&lt;br/&gt;Sticky file scaffold\"]\n        tracker[\"tracker.js&lt;br/&gt;Tool classification\"]\n        guard[\"memory-guard.js&lt;br/&gt;MEMORY.md protection\"]\n        debug[\"debug.js&lt;br/&gt;Debug logging\"]\n        hooklog[\"hook-logger.js&lt;br/&gt;Event logging\"]\n    end\n\n    subgraph claude[\"Claude Code (.lore/hooks/)\"]\n        cc_si[session-init.js]\n        cc_pp[prompt-preamble.js]\n        cc_pm[protect-memory.js]\n        cc_cg[convention-guard.js]\n        cc_fg[framework-guard.js]\n        cc_kt[knowledge-tracker.js]\n        cc_cp[context-path-guide.js]\n    end\n\n    subgraph cursor[\"Cursor (.cursor/hooks/ + .cursor/mcp/)\"]\n        cu_si[session-init.js]\n        cu_cn[capture-nudge.js]\n        cu_cf[compaction-flag.js]\n        cu_ft[failure-tracker.js]\n        cu_pm[protect-memory.js]\n        cu_kt[knowledge-tracker.js]\n        cu_mcp[lore-server.js&lt;br/&gt;MCP: lore_check_in, lore_context, lore_write_guard]\n    end\n\n    subgraph opencode[\"OpenCode (.opencode/plugins/)\"]\n        oc_si[session-init.js]\n        oc_pm[protect-memory.js]\n        oc_cg[convention-guard.js]\n        oc_fg[framework-guard.js]\n        oc_kt[knowledge-tracker.js]\n        oc_cp[context-path-guide.js]\n    end\n\n    cc_si &amp; cu_si &amp; oc_si --&gt; banner\n    banner --&gt; tree &amp; config &amp; sticky\n    cc_kt &amp; cu_kt &amp; oc_kt --&gt; tracker\n    cu_cn --&gt; tracker &amp; config\n    cu_mcp --&gt; banner &amp; tracker &amp; config\n    cc_pm &amp; cu_pm &amp; oc_pm --&gt; guard\n    cc_cg &amp; cc_fg &amp; oc_cg &amp; oc_fg --&gt; guard &amp; config\n    cc_cp &amp; oc_cp --&gt; banner\n    tracker &amp; guard &amp; tree &amp; config --&gt; debug\n    cc_si &amp; cu_si &amp; oc_si &amp; cc_kt &amp; cu_kt &amp; oc_kt &amp; cu_cn --&gt; hooklog</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"guides/hook-architecture/#banner-loaded-skills","title":"Banner-Loaded Skills","text":"<p>Skills with <code>banner-loaded: true</code> in their YAML frontmatter have their full body inlined into the session banner at startup. Use <code>banner-loaded: true</code> for high-priority skills that must always be in context without explicit loading.</p> <pre><code>---\nname: my-skill\nbanner-loaded: true\n---\n# Skill content inlined into every session banner\n</code></pre> <p>Standard skills (without <code>banner-loaded: true</code>) are listed by name in the knowledge map tree but not loaded automatically.</p>"},{"location":"guides/hook-architecture/#platform-adapters","title":"Platform Adapters","text":"<p>Each platform has a different hook API. Adapters translate between the platform's interface and the shared <code>lib/</code> functions.</p> Hook Point Claude Code Cursor OpenCode Session start <code>SessionStart</code> <code>sessionStart</code> <code>SessionInit</code> Per-prompt <code>UserPromptSubmit</code> -- <code>chat.system.transform</code> Memory guard <code>PreToolUse</code> <code>beforeReadFile</code> + <code>preToolUse</code> <code>tool.execute.before</code> Knowledge tracker <code>PostToolUse</code> <code>afterFileEdit</code> (silent) <code>tool.execute.after</code> Capture nudge <code>PostToolUse</code> (in knowledge-tracker) <code>beforeShellExecution</code> <code>tool.execute.after</code> (in knowledge-tracker) Context path guide <code>PreToolUse</code> -- <code>tool.execute.before</code> MCP tools -- <code>lore_check_in</code> + <code>lore_context</code> -- Compaction <code>SessionStart</code> re-fires <code>preCompact</code> flag <code>session.compacting</code> <p>Cursor does not display output from <code>afterFileEdit</code>, <code>postToolUseFailure</code>, or <code>preCompact</code> hooks to the agent, and has no per-prompt hook. The MCP server (<code>lore_check_in</code>, <code>lore_context</code>) compensates by providing on-demand access to nudges and the knowledge map.</p> <p>See Platform Support for the feature matrix and setup details.</p>"},{"location":"guides/hook-architecture/#hook-behavior-notes","title":"Hook Behavior Notes","text":""},{"location":"guides/hook-architecture/#framework-guardjs","title":"framework-guard.js","text":"<p>Detects whether the agent is operating in a Lore hub repo or a linked work repo. Enforces different guardrails in each context \u2014 hub repos block application code creation; linked repos block direct edits to hub knowledge files. Fires on <code>PreToolUse</code> for file write operations.</p>"},{"location":"guides/hook-architecture/#context-path-guidejs","title":"context-path-guide.js","text":"<p>Fires when the agent accesses files under <code>docs/context/</code> or <code>docs/knowledge/</code>. Outputs a knowledge map tree to help the agent navigate to the right location for context reads and writes. Fires on <code>PreToolUse</code>.</p>"},{"location":"guides/hook-architecture/#failure-trackerjs-cursor","title":"failure-tracker.js (Cursor)","text":"<p>Sets a flag when a tool use fails. The <code>capture-nudge.js</code> hook reads the flag in <code>beforeShellExecution</code> to deliver capture reminders when the agent transitions from a failed tool use to a shell command. The two-hook pattern compensates for Cursor not displaying <code>postToolUseFailure</code> output to the agent.</p>"},{"location":"guides/hook-architecture/#ensure-structuresh","title":"ensure-structure.sh","text":"<p>Runs on <code>SessionStart</code>. Creates stub <code>index.md</code> files for any knowledge directories that don't have one. Prevents empty directory entries from appearing in the knowledge map without any navigation context.</p>"},{"location":"guides/hook-architecture/#read-only-tool-reset","title":"Read-only tool reset","text":"<p>When the agent uses a read-only tool (Read, Glob, Grep, WebFetch), the Bash command counter resets to 0 rather than incrementing. Capture nudges only accumulate against shell commands \u2014 reading files does not count toward the nudge or warn thresholds.</p>"},{"location":"guides/interaction/","title":"Working with Lore","text":"<p>You direct, Lore captures. Each session builds on the last. You don't need to set anything up, create roadmaps, or plan ahead \u2014 just start working. Hooks prompt knowledge capture as you go. Use <code>/lore-capture</code> after substantive work to ensure nothing was missed.</p>"},{"location":"guides/interaction/#just-work","title":"Just Work","text":"Action Example Ask for work \"Connect us to Jira and pull all open INFRA tickets\" Share context \"The VPN endpoint is 10.0.1.1 and the Azure tenant ID is abc-123 \u2014 remember that\" Request documentation \"Document the architecture decisions we just made\" Ask questions \"What agents do we have available?\" <p>Skills and agents emerge from demonstrated need, not upfront planning.</p>"},{"location":"guides/interaction/#tips","title":"Tips","text":"Approach Why Work naturally, let skills emerge Skills are best when they capture real gotchas from actual work Let workers handle complex tasks The orchestrator delegates with curated skills \u2014 no upfront agent planning Break compound work into branches Independent branches can run in parallel subagents; dependency chains stay sequential Bring your own skills Copy them in, run <code>/lore-capture</code> \u2014 see below Let Lore maintain registries Registries, nav, and cross-references are where consistency matters most"},{"location":"guides/interaction/#bringing-existing-skills","title":"Bringing Existing Skills","text":"<p>If you have skills from other projects or custom markdown files you've been copying between repos, Lore can absorb them.</p> <p>What to do:</p> <ol> <li>Copy your skill files into <code>.lore/skills/&lt;skill-name&gt;/SKILL.md</code></li> <li> <p>Each skill needs YAML frontmatter with two required fields:</p> <pre><code>---\nname: my-api-quirk\ndescription: One-line summary of what this skill captures\n---\n</code></pre> </li> <li> <p>Run <code>/lore-capture</code> \u2014 it updates registries and syncs to all platforms</p> </li> </ol> <p>Workers load skills dynamically. Don't copy agents between projects. Instead, import your skills \u2014 the orchestrator selects the right ones per-task by name and description when spawning workers. Operator agents are optional for recurring delegation patterns.</p> <p>After import, sharing is automatic. Once skills are in your Lore hub, every linked repo gets them. No more copying between projects.</p>"},{"location":"guides/interaction/#roadmaps-plans-brainstorms","title":"Roadmaps, Plans &amp; Brainstorms","text":"<p>See Roadmaps &amp; Plans.</p>"},{"location":"guides/interaction/#command-reference","title":"Command Reference","text":"<p>Commands are slash-invoked skills.</p>"},{"location":"guides/interaction/#knowledge-capture","title":"Knowledge Capture","text":"Command What it does <code>/lore-capture</code> Review session work, capture skills, update registries, validate consistency <code>/lore-consolidate</code> Deep health check \u2014 find stale items, semantic overlaps, knowledge drift <p><code>/lore-capture</code> is the primary end-of-session command.</p>"},{"location":"guides/interaction/#work-management","title":"Work Management","text":"<p>See Roadmaps &amp; Plans for format and workflow.</p>"},{"location":"guides/interaction/#instance-management","title":"Instance Management","text":"Command What it does <code>/lore-status</code> Show Lore version, hook health, skill/agent counts, active work <code>/lore-update</code> Pull latest framework files from GitHub without touching operator content <p>See Platform Support: Sync Boundaries for what <code>/lore-update</code> does and doesn't touch.</p>"},{"location":"guides/interaction/#cross-repo-linking","title":"Cross-Repo Linking","text":"Command What it does <code>/lore-link &lt;target&gt;</code> Link a work repo \u2014 hooks fire from hub <p>See Cross-Repo Workflow for full flag reference.</p>"},{"location":"guides/interaction/#docs-ui","title":"Docs UI","text":"Command What it does <code>/lore-docker</code> Start, stop, or check the local Docker sidecar \u2014 provides semantic search and a live MkDocs UI. Falls back to local mkdocs if Docker is unavailable. See Docs UI &amp; Semantic Search."},{"location":"guides/platform-support/","title":"Platform Support","text":"<p>Lore supports three coding agent platforms. All share the same knowledge base \u2014 skills, agents, docs, and work tracking persist across platforms.</p>"},{"location":"guides/platform-support/#feature-matrix","title":"Feature Matrix","text":"Feature Claude Code Cursor OpenCode Session banner Yes Yes Yes Per-prompt reinforcement Yes (conversation history) No (compensated by MCP tools) Yes (system prompt, zero accumulation) MCP tools No Yes (<code>lore_check_in</code>, <code>lore_context</code>, <code>lore_write_guard</code>) No MEMORY.md guard Yes Yes Yes Knowledge capture reminders Yes Yes Yes Bash escalation tracking Yes Yes Yes Context path guide Yes No Yes Compaction resilience SessionStart re-fires Flag + re-orientation on next cmd/MCP Compacting event re-injects Hook event logging Yes Yes Yes Instructions <code>CLAUDE.md</code> <code>.cursor/rules/lore-*.mdc</code> <code>.lore/instructions.md</code>"},{"location":"guides/platform-support/#hook-directories","title":"Hook Directories","text":"<pre><code>hooks/              \u2192 Claude Code (subprocess per event)\n.cursor/hooks/      \u2192 Cursor (subprocess per event)\n.cursor/mcp/        \u2192 Cursor MCP server (long-lived process)\n.opencode/plugins/  \u2192 OpenCode (long-lived ESM modules)\nlib/                \u2192 Shared logic (all platforms)\n</code></pre> <p>See Hook Architecture for module layout and lifecycle diagrams.</p>"},{"location":"guides/platform-support/#claude-code","title":"Claude Code","text":"<p>Full hook coverage across all lifecycle events.</p> <ul> <li>Config: <code>.claude/settings.json</code></li> <li>7 hooks: session banner, per-prompt reminder, context path guide, memory guard, convention guard, framework guard, knowledge tracker</li> </ul> <p>See Hook Architecture for the full event reference.</p> <p><code>SessionStart</code> re-fires after compaction, so the full banner is always present.</p>"},{"location":"guides/platform-support/#cursor","title":"Cursor","text":"<p>Hooks plus an MCP server to compensate for missing per-prompt events.</p> <ul> <li>Config: <code>.cursor/hooks.json</code> + <code>.cursor/mcp.json</code></li> <li>6 hooks: session banner, capture nudge (beforeShellExecution), compaction flag, failure tracker, knowledge tracker, memory guard</li> <li>MCP tools: <code>lore_check_in</code> (nudges), <code>lore_context</code> (knowledge map), <code>lore_write_guard</code> (convention reminders)</li> </ul> <p>See Hook Architecture for the full event reference.</p> <p>Cursor does not display output from <code>afterFileEdit</code>, <code>postToolUseFailure</code>, or <code>preCompact</code> to the agent. Those hooks write state to disk; <code>beforeShellExecution</code> and the MCP server read the state back when they fire.</p> <p>Gaps: No per-prompt hook, no context path guide.</p>"},{"location":"guides/platform-support/#opencode","title":"OpenCode","text":"<p>Long-lived ESM plugins with system prompt injection.</p> <ul> <li>Config: <code>opencode.json</code> + <code>.opencode/plugins/</code></li> <li>6 plugins: session banner + system transform, context path guide, memory guard, convention guard, framework guard, knowledge tracker</li> </ul> <p>See Hook Architecture for the full event reference.</p> <p><code>chat.system.transform</code> fires on every LLM call. The first call injects the full banner (~14K chars); subsequent calls inject a compact reminder (~200 chars). After context compaction, the full banner is restored on the next call.</p>"},{"location":"guides/platform-support/#setup","title":"Setup","text":"<p>All platforms activate automatically after <code>npx create-lore</code>.</p> Platform What loads Claude Code <code>CLAUDE.md</code> + <code>.claude/settings.json</code> Cursor <code>.cursor/rules/lore-*.mdc</code> + <code>.cursor/hooks.json</code> + <code>.cursor/mcp.json</code> OpenCode <code>opencode.json</code> + <code>.opencode/plugins/</code> + <code>.opencode/commands/</code> <p><code>CLAUDE.md</code> is generated from <code>.lore/instructions.md</code>. Cursor <code>.mdc</code> rules are generated from multiple sources (instructions, agent-rules, conventions, agent-registry). Run <code>bash .lore/scripts/sync-platform-skills.sh</code> after editing any of those source files to keep platform copies in sync.</p>"},{"location":"guides/platform-support/#sync-boundaries","title":"Sync Boundaries","text":"<p><code>/lore-update</code> and <code>sync-framework.sh</code> overwrite framework infrastructure (<code>.lore/hooks/</code>, <code>.lore/lib/</code>, <code>.lore/scripts/</code>, <code>.opencode/</code>, <code>.cursor/hooks/</code>) and <code>lore-*</code> prefixed skills/agents. Operator content is never touched.</p> Category Synced Operator-owned <code>lore-*</code> skills/agents Yes \u2014 Operator skills/agents \u2014 Yes <code>.lore/hooks/</code>, <code>.lore/lib/</code>, <code>.lore/scripts/</code> Yes \u2014 <code>docs/</code>, <code>mkdocs.yml</code>, <code>.lore/config.json</code> \u2014 Yes <p><code>.lore/config.json</code> controls subagent model defaults \u2014 see Configuration: subagentDefaults.</p> <p>See Cross-Repo Workflow for how <code>/lore-link</code> generates and gitignores config files in work repos.</p>"},{"location":"guides/roadmaps-and-plans/","title":"Roadmaps &amp; Plans","text":"<p>Lore tracks strategic and tactical work through roadmaps (multi-phase initiatives) and plans (specific implementation tasks). Both are operator-initiated \u2014 Lore maintains them but asks before updating.</p>"},{"location":"guides/roadmaps-and-plans/#roadmaps-vs-plans","title":"Roadmaps vs Plans","text":"Aspect Roadmap Plan Scope Strategic initiative (weeks-months) Tactical task (days-weeks) Purpose Track overall progress across phases Describe implementation approach Quantity One per initiative Many per roadmap, or standalone"},{"location":"guides/roadmaps-and-plans/#format","title":"Format","text":"<p>See Example Roadmap and Example Plan for templates with full YAML frontmatter.</p>"},{"location":"guides/roadmaps-and-plans/#hierarchy","title":"Hierarchy","text":"<p>Plans can nest under roadmaps in two ways:</p> <p>Folder nesting (location implies relationship):</p> <pre><code>docs/work/roadmaps/&lt;initiative&gt;/plans/&lt;plan&gt;/index.md\n</code></pre> <p>Frontmatter link (standalone plan referencing a roadmap):</p> <pre><code>roadmap: &lt;roadmap-slug&gt;\n</code></pre> <p>Only for standalone plans that reference a roadmap \u2014 not for plans nested under a roadmap folder (the folder location already implies the relationship).</p>"},{"location":"guides/roadmaps-and-plans/#creating","title":"Creating","text":"<p>Ask Lore to create work items conversationally:</p> <ul> <li>\"Create a roadmap for cloud migration\"</li> <li>\"Create a plan for the networking setup\" \u2014 Lore will determine whether to nest it under a roadmap or keep it standalone</li> <li>\"Start a brainstorm about auth options\" \u2014 for exploratory discussions and ADRs</li> </ul>"},{"location":"guides/roadmaps-and-plans/#status-workflow","title":"Status Workflow","text":"<pre><code>active \u2192 on-hold \u2192 active (resumed)\n       \u2198 archived (move folder to archive/)\n</code></pre> <ul> <li>active: Shown in the session banner every session</li> <li>on-hold: Shown in the session banner with <code>[ON HOLD]</code> suffix</li> <li>completed: Finished; keep <code>status: completed</code> and move folder to <code>archive/</code></li> <li>cancelled: Stopped/abandoned; keep <code>status: cancelled</code> and move folder to <code>archive/</code></li> </ul>"},{"location":"guides/roadmaps-and-plans/#allowed-status-values","title":"Allowed Status Values","text":"<p>Use exactly these values for roadmap/plan frontmatter:</p> <ul> <li><code>active</code></li> <li><code>on-hold</code></li> <li><code>completed</code></li> <li><code>cancelled</code></li> </ul> <p><code>archived</code> is a folder location, not a status value.</p>"},{"location":"guides/roadmaps-and-plans/#archiving","title":"Archiving","text":"<p>To archive: move the folder to the parent's <code>archive/</code> subdirectory \u2014 <code>docs/work/roadmaps/&lt;slug&gt;/archive/</code> for roadmap plans, <code>docs/work/plans/archive/</code> for standalone plans. <code>/lore-capture</code> prompts this step.</p> <p>See also: Example Brainstorm</p>"},{"location":"knowledge/","title":"Knowledge","text":"<p>The <code>knowledge/</code> directory is where Lore stores everything discovered during sessions: environment facts, reusable runbooks, and operator-local preferences. Unlike <code>context/</code>, knowledge files are written by the agent as it learns \u2014 not pre-authored upfront.</p> <ul> <li>Environment</li> <li>Runbooks</li> </ul>"},{"location":"knowledge/environment/","title":"Environment","text":"<p>The <code>environment/</code> directory maps the infrastructure and services the agent interacts with: URLs, repos, accounts, API endpoints, auth requirements, and relationships between components. Facts captured here are referenced by skills and runbooks so the agent doesn't re-discover them each session.</p>"},{"location":"knowledge/local/","title":"Local","text":""},{"location":"knowledge/local/operator-profile/","title":"Operator Profile","text":""},{"location":"knowledge/local/operator-profile/#identity","title":"Identity","text":"<ul> <li>Name:</li> <li>Role:</li> </ul>"},{"location":"knowledge/local/operator-profile/#preferences","title":"Preferences","text":"<p>Add preferences, working style notes, or context that should be available to the agent in every session.</p>"},{"location":"knowledge/runbooks/","title":"Runbooks","text":"<p>The <code>runbooks/</code> directory holds step-by-step procedures for multi-step operations \u2014 deploy sequences, incident response flows, release checklists, and similar repeatable workflows. Runbooks are written during <code>/lore-capture</code> when a task required more than a single skill to document correctly.</p>"},{"location":"stylesheets/","title":"Stylesheets","text":""},{"location":"work/","title":"Work","text":"<p>The <code>work/</code> directory tracks active and archived work items: strategic roadmaps, tactical plans, and exploratory brainstorms. All work items are operator-initiated \u2014 Lore maintains them but asks before creating or updating. Active roadmaps and plans surface in the session banner so long-running projects always have context at startup.</p> <ul> <li>Roadmaps</li> <li>Plans</li> <li>Brainstorms</li> </ul>"},{"location":"work/brainstorms/","title":"Brainstorms","text":"<p>The <code>brainstorms/</code> directory holds exploratory discussions and ADRs: options considered, trade-offs weighed, and rationale recorded for future reference. Brainstorms document thinking rather than track work progress, so they have no status field and do not appear in the session banner.</p>"},{"location":"work/plans/","title":"Plans","text":"<p>The <code>plans/</code> directory holds tactical work items scoped to days or weeks. Plans can be standalone or nested under a roadmap folder. Active plans appear in the session banner; completed or cancelled plans move to <code>plans/archive/</code>. See Roadmaps &amp; Plans for format and status workflow.</p>"},{"location":"work/roadmaps/","title":"Roadmaps","text":"<p>The <code>roadmaps/</code> directory holds strategic initiatives scoped to weeks or months. Each roadmap tracks overall progress across phases and contains nested <code>plans/</code> and <code>archive/</code> folders. Active roadmaps appear in the session banner every session. See Roadmaps &amp; Plans for format and status workflow.</p>"}]}